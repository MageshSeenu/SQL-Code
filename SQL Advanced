SET 1: Conceptual & SQL Basics		
		
1. Difference between RANK() and DENSE_RANK()		
		
Concept	Explanation	
RANK()	Assigns rank to rows; skips rank(s) if thereâ€™s a tie.	
DENSE_RANK()	Assigns rank to rows; no ranks are skipped in case of tie.	
		
Example:		
		
salary	RANK()	DENSE_RANK()
90000	1	1
85000	2	2
85000	2	2
80000	4	3
		
		
2. Correlated vs Non-correlated Subqueries		
		
Type	Explanation	
Correlated	Inner query depends on outer query; runs for each outer row.	
Non-Correlated	Inner query runs once; result used by outer query.	
		
		
3. UNION vs UNION ALL vs INTERSECT vs EXCEPT		
		
Operator	Meaning	
UNION	Combine tables; remove duplicates	
UNION ALL	Combine tables; keep duplicates	
INTERSECT	Return only rows common to both tables	
EXCEPT	Return rows in first table not in second table	
		
		
4. INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN (performance)		
		
Join Type	Result	Performance Note
INNER JOIN	Only matching rows from both tables	Usually fastest, smaller result set
LEFT JOIN	All rows from left + matching right rows	Slightly slower, returns more rows
RIGHT JOIN	All rows from right + matching left rows	Similar to LEFT JOIN
FULL OUTER JOIN	All rows from both tables	Slowest; combines all, fills nulls
		
		
5. CTEs: Recursive vs Non-Recursive		
		
Type	Explanation	
Non-Recursive	Simple temporary result set for readability	
Recursive	Refers to itself; used for hierarchical or iterative data	
		
Example: Recursive CTE		
		
WITH numbers AS (		
    SELECT 1 AS num		
    UNION ALL		
    SELECT num + 1 FROM numbers WHERE num < 10		
)		
SELECT num FROM numbers;		
		
		
		
SET 2: SQL Questions Completed After Set 1		
		
1. Second Highest Salary (handling duplicates)		
		
SELECT emp_name, salary		
FROM (		
    SELECT emp_name, salary,		
           DENSE_RANK() OVER (ORDER BY salary DESC) AS rn		
    FROM employees		
) t		
WHERE rn = 2;		
		
		
		
2. Employees earning more than dept average		
		
SELECT emp_id, dept_id, salary		
FROM employees e		
WHERE salary > (		
    SELECT AVG(salary)		
    FROM employees ee		
    WHERE e.dept_id = ee.dept_id		
);		
		
		
		
3. Cumulative sales (running total)		
		
SELECT emp_id, sale_date, sale_amount,		
       SUM(sale_amount) OVER (PARTITION BY emp_id ORDER BY sale_date) AS running_total		
FROM sales;		
		
		
		
4. Monthly average salary trend for 2023		
		
WITH monthyear AS (		
    SELECT EXTRACT(YEAR FROM joining_date) AS year,		
           EXTRACT(MONTH FROM joining_date) AS month,		
           salary		
    FROM employees		
)		
SELECT month, AVG(salary) AS monthly_avg		
FROM monthyear		
WHERE year = 2023		
GROUP BY month		
ORDER BY month;		
		
		
		
5. Employees without a department		
		
SELECT e.emp_name		
FROM employees e		
WHERE NOT EXISTS (		
    SELECT 1		
    FROM departments d		
    WHERE e.dept_id = d.dept_id		
);		
		
		
		
6. Employees who joined on the same date (self-join)		
		
SELECT e1.emp_id, e1.emp_name		
FROM employees e1		
JOIN employees e2		
  ON e1.joining_date = e2.joining_date		
 AND e1.emp_id <> e2.emp_id		
ORDER BY e1.joining_date;		
		
		
		
7. Department with maximum total salary		
		
SELECT dept_id, SUM(salary) AS total_salary		
FROM employees		
GROUP BY dept_id		
ORDER BY SUM(salary) DESC		
LIMIT 1;		
		
		
		
8. 5th highest salary without TOP/LIMIT/OFFSET		
		
SELECT salary		
FROM (		
    SELECT emp_name, salary,		
           DENSE_RANK() OVER (ORDER BY salary DESC) AS rn		
    FROM employees		
) t		
WHERE rn = 5;		
		
		
		
9. Employees joined in same month but different years		
		
WITH months AS (		
    SELECT emp_name, EXTRACT(MONTH FROM joining_date) AS mon		
    FROM employees		
)		
SELECT e.emp_name, e.mon, ee.emp_name, ee.mon		
FROM months e		
JOIN months ee		
  ON e.mon = ee.mon		
 AND e.emp_name <> ee.emp_name;		
		
		
		
10. Employees above dept and company average		
		
SELECT *		
FROM (		
    SELECT emp_name, dept_id, salary,		
           AVG(salary) OVER (PARTITION BY dept_id) AS dept_avg,		
           AVG(salary) OVER () AS company_avg		
    FROM employees		
) t		
WHERE salary > dept_avg		
  AND salary > company_avg;		
		
		
		
11. First and last sale date per employee (window functions)		
		
SELECT emp_id,		
       sale_date,		
       sale_amount,		
       FIRST_VALUE(sale_date) OVER (PARTITION BY emp_id ORDER BY sale_date ASC) AS first_sale,		
       LAST_VALUE(sale_date) OVER (		
           PARTITION BY emp_id		
           ORDER BY sale_date ASC		
           ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING		
       ) AS last_sale		
FROM sales		
ORDER BY emp_id, sale_date;		
		
		
		
12. ROWS BETWEEN examples for running totals		
		
-- Running total (default)		
SUM(sale_amount) OVER (PARTITION BY emp_id ORDER BY sale_date)		
		
-- Running total including previous row		
SUM(sale_amount) OVER (PARTITION BY emp_id ORDER BY sale_date 		
                       ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)		
		
-- Reverse cumulative sum		
SUM(sale_amount) OVER (PARTITION BY emp_id ORDER BY sale_date 		
                       ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)		
